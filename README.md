# Приложение для создания и редактирования информации о встречах сотрудников

Написано для Node.js 8 и использует библиотеки:
* express
* sequelize
* graphql

## Задание
Код содержит ошибки разной степени критичности. Некоторых из них стилистические, а некоторые даже не позволят вам запустить приложение. Вам необходимо найти и исправить их.

Пункты для самопроверки:
1. Приложение должно успешно запускаться
2. Должно открываться GraphQL IDE - http://localhost:3000/graphql/
3. Все запросы на получение или изменения данных через graphql должны работать корректно. Все возможные запросы можно посмотреть в вкладке Docs в GraphQL IDE или в схеме (typeDefs.js)
4. Не должно быть лишнего кода
5. Все должно быть в едином codestyle

## Запуск
```
npm i
npm run dev
```

Для сброса данных в базе:
```
npm run reset-db
```


## Заметки

Перед тем как начать отчет по проделанной работе, хотел бы отметить, что ни с graphql, ни с sequelize прошлого опыта не было, поэтому о наличии массового гуглинга я сообщу заранее.

В качестве редактора и IDE я пользовался Webstorm'ом.

1. Приложение должно успешно запускаться

    Запустив приложение, сразу высвечивается ошибка `Error: Dialect needs to be explicitly supplied as of v4.0.0`.
    
    `models/index.js, 7`
    
    Диалект передается в конфигурационном объекте, который передается 4-ым аргументом, а в коде был передан 3-им. Было пропущено название базы данных в 1-ом аргументе конструктора.
    
    Теперь приложение запускается. Домашняя страница с приветствием открывается.

2. Должно открываться GraphQL IDE - http://localhost:3000/graphql/

    `index.js, 14`
    
    Оно не открывалось по этой ссылке, потому что путь, прописанный в `app`е был ошибочно прописан. После исправления графическая оболочка открывается.
    
3. Все запросы на получение или изменения данных через graphql должны работать корректно. Все возможные запросы можно посмотреть в вкладке Docs в GraphQL IDE или в схеме (typeDefs.js)

    Здесь обычно помогают тесты, но я решил их сделать в конце и проверить пока руками (тесты как раз покажут то, что я упустил).
    
    #### query

    Начал я с попытки вытащить все данные с каждой таблицы - `users`, `rooms` и `events`. `users` работало без проблем, `rooms` выдавало все, кроме первого, а `еvents` выдавало ошибку.
    
    В файле `graphql/resolvers/query.js` я заметил, что все эти запросы используют метод `findAll`, которому требуется лишь один аргумент с параметрами для запроса. Во всех запросах я не стал ничего передавать, так как без параметров по умолчанию `sequelize` возвращает все.
    
    `events` начал работать, но вместо отношений возвращался `null`. За отношения отвечали методы, прописанные в `graphql/resolvers/index.js`. В них не хватало `return`ов.
    
    Так же все изменения с пользователями не принимали `avatarUrl`. Поля не хватало в схеме.
    
    Запросы по `id` работали исправно.
    
    #### mutation
    
    Здесь начался конфликт дизайна. Если проверку на `null` делать в `graphql`, то создание и изменение начнут конфликтовать (ведь нам необязательно менять все поля при изменении, а `graphql` будет ждать наличия всех полей, указанных как те, которые не могут быть `null`). Эту логику я перенес в модели `sequelize`.
    
    В методе `createEvent` создавалось мероприятие при неправильном `id` комнаты. Так же при отсутствии пользователей выдавалась ошибка, но мероприятие все равно создавалось.
    
    Все запросы проходили без проблем, кроме `addUserToEvent` и `changeEventRoom`. В первом случае метод не был реализован в `graphql/resolvers/mutation.js`. Во втором был использован неправильный аргумент для изменения комнаты (`id` вместо `roomId`).
    
    Так же при удалении комнаты не удалялись мероприятия. Они не должны удаляться, если должна храниться история мероприятий, но, так как точной схемы БД и логики приложения на этот счет не предоставлены, я добавил удаление событий при удалении комнаты.
    
4. Не должно быть лишнего кода

    Лишний код выходил у меня за счет логов в консоли при тестировании, поэтому они были удалены.
    
5. Все должно быть в едином codestyle

    В этом помог уже подключенный `semistandard`, который выявил ошибку с неустановленным модулем `body-parser`, которую я пропустил.
    
#### Бонусная часть

Для реализации тестов я провел рефакторинг приложения.

1. В `package.json` при запуске приложения и тестов добавлено имя среды (`dev` для приложения, `test` для тестов, можно так же использовать `prod` при релизе).
2. Отделил декларацию и запуск приложения (декларация находится в `app.js`).
3. Отделил БД для разных сред (в названии добавил имя среды).

Для тестирования я использовал

* `mocha` для запуска тестов
* `chai` в качестве фреймворка для проверки
* `axios` для запросов

В процессе реализации тестов произошла дилемма между DRY кодом и читабельностью. Тесты гораздо более читабельны, если все расписано максимально близко к разговорному языку, однако очень много тестов повторялось. В итоге я сделал выбор в пользу DRY.

После реализации тестов была найдена ошибка в том, что при удалении несуществующего пользователя с мероприятия не выдавалась ошибка.
